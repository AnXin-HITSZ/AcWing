# 3. shell 语法

**目录：**

[TOC]

---

## 一、概论

shell 是我们通过命令行与操作系统沟通的语言，是一门解释型语言，无需编译即可执行。

shell 脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。

AC Terminal 中的命令行可以看成一个“**shell 脚本在逐行执行**”。

Linux 中常见的 shell 脚本有很多种，常见的有：
* Bourne Shell（`/usr/bin/sh` 或 `/bin/sh`）；
* Bourne Again Shell（`/bin/bash`）；
* C Shell（`/usr/bin/csh`）；
* K Shell（`/usr/bin/ksh`）；
* zsh；
* ……

Linux 系统中一般默认使用 bash，所以接下来讲解 bash 中的语法。

文件开头需要写 `#! /bin/bash`，指明 bash 为脚本解释器。

**脚本示例**

新建一个 `test.sh` 文件，内容如下：
```shell
#! /bin/bash
echo "Hello World!"
```

> 注意：`echo` 类似于 C++ 中的 `cout` 或 `printf`，即其功能为输出字符串。

**运行方式**

作为可执行文件：
```bash
acs@9e0ebfcd82d7:~$ chmod +x test.sh    # 使脚本具有可执行权限
acs@9e0ebfcd82d7:~$ ./test.sh   # 当前路径下执行
Hello World!    # 脚本输出
acs@9e0ebfcd82d7:~$ /home/acs/test.sh   # 绝对路径下执行
Hello World!    # 脚本输出
acs@9e0ebfcd82d7:~$ ~/test.sh   # 家目录路径下执行
Hello World!
```

用解释器执行：
```bash
acs@9e0ebfcd82d7:~$ bash test.sh
Hello World!    # 脚本输出
```

## 二、注释

### 2.1 单行注释

每行中 `#` 之后的内容均是注释。

示例代码：
```shell
# 这是一行注释

echo 'Hello World'  # 这也是注释
```

### 2.2 多行注释

格式：
```shell
:<<EOF
第一行注释
第二行注释
第三行注释
EOF
```

其中 `EOF` 可以换成其他任意字符串。例如：
```shell
:<<abc
第一行注释
第二行注释
第三行注释
abc

:<<!
第一行注释
第二行注释
第三行注释
!
```

## 三、变量

### 3.1 定义变量

定义变量，不需要加 `$` 符号。例如：
```shell
name1='yxc' # 单引号定义字符串
name2="yxc" # 双引号定义字符串
name3=yxc   # 也可以不加引号，同样表示字符串
```

定义变量的时候变量都是字符串；但当变量需要是整数时，会自动把变量转换成整数。

> 注意：定义变量时 `=` 两边不能有空格，否则会报错。

### 3.2 使用变量

使用变量，需要加上 `$` 符号，或者 `${}` 符号。花括号是可选的，主要为了帮助解释器识别变量边界。

示例代码：
```shell
name=yxc
echo $name  # 输出：yxc
echo ${name}    # 输出：yxc

echo ${name}acwing  # 输出：yxcacwing
# 等价于：
echo "${name}acwing"    # 输出：yxcacwing
```

> 注意：如果一个变量不存在的话，它的值是空字符串。

### 3.3 只读变量

使用 `readonly` 或者 `declare` 可以将变量变为只读。

示例代码：
```shell
name=yxc
readonly name
declare -r name # 两种写法均可

name=abc  # 会报错，因为此时 name 只读
```

> 注意：
> * 被声明为只读的变量无法被 `unset` 删除。
> * 在执行 `type readonly` 命令后，输出 `readonly is a shell builtin`，表明 `readonly` 命令为 shell 内部命令。

### 3.4 删除变量

`unset` 可以删除变量。

示例代码：
```shell
name=yxc
unset name
echo $name  # 输出空行
```

### 3.5 变量类型

变量类型有如下两种：
1. 自定义变量（局部变量）：子进程不能访问的变量。
2. 环境变量（全局变量）：子进程可以访问的变量。

> 注意：`bash` 命令将会开启一个新的进程，原进程将会睡眠；`exit` 命令或 `Ctrl + d` 组合键可以退出新的 bash。

自定义变量改成环境变量：
```bash
acs@9e0ebfcd82d7:~$ name=yxc    # 定义变量
acs@9e0ebfcd82d7:~$ export name # 第一种方法
acs@9e0ebfcd82d7:~$ declare -x name # 第二种方法
```

环境变量改为自定义变量：
```bash
acs@9e0ebfcd82d7:~$ export name=yxc # 定义环境变量
acs@9e0ebfcd82d7:~$ declare +x name # 改为自定义变量
```

### 3.6 字符串

字符串可以用单引号，也可以用双引号，也可以不用引号。

单引号与双引号的区别：
* 单引号中的内容会原样输出，不会执行、不会取变量；
* 双引号中的内容可以执行、可以取变量。

> 注意：字符串中，不加引号和双引号的效果是一样的。

示例代码：
```shell
name=yxc    # 不用引号
echo 'hello, $name \"hh\"'  # 单引号字符串，输出：hello, $name \"hh\"
echo "hello, $name \"hh\""  # 双引号字符串，输出：hello, yxc "hh"
```

获取字符串长度：
```shell
name="yxc"
echo ${#name}   # 输出：3
```

提取子串：
```shell
name="hello, yxc"
echo ${name:0:5}    # 提取从 0 开始的 5 个字符
```

> 注意：提取子串时，左闭右开取子串。

## 四、默认变量

默认变量是局部变量（自定义变量）。

### 4.1 文件参数变量

在执行 shell 脚本时，可以向脚本传递参数。`$1` 是第一个参数，`$2` 是第二个参数，以此类推。特殊的，`$0` 是文件名（包含路径）。例如：

创建文件 `test.sh`：
```shell
#! /bin/bash

echo "文件名："$0
echo "第一个参数："$1
echo "第二个参数："$2
echo "第三个参数："$3
echo "第四个参数："$4
```

然后执行该脚本：
```bash
acs@9e0ebfcd82d7:~$ chmod +x test.sh
acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4
文件名：./test.sh
第一个参数：1
第二个参数：2
第三个参数：3
第四个参数：4
```

> 注意：在 `$n` 中，当 `n` 为两位数时，需要使用 `{}` 括起来，类似于 Markdown 语法格式。

### 4.2 其它参数相关变量

其他参数相关变量：
| 参数 | 说明 |
| :--: | :--: |
| `$#` | 代表文件传入的参数个数，如上例中值为 `4` |
| `$*` | 由所有参数构成的用空格隔开的字符串，如上例中值为 `"$1 $2 $3 $4"` |
| `$@` | 每个参数分别用双引号括起来的字符串，如上例中值为 `"$1" "$2" "$3" "$4"` |
| `$$` | 脚本当前运行的进程 ID |
| `$?` | 上一条命令的退出状态（注意不是 stdout，而是 exit code）；`0` 表示正常退出，其他值表示错误 |
| `$(command)` | 返回 `command` 这条命令的 stdout（可嵌套） |
| \`command\` | 返回 `command` 这条命令的 stdout（不可嵌套） |

> 注意：命令的退出状态（exit code）相当于 C++ 中的 `return n`，而命令的 stdout 相当于 C++ 中的 `cout`。

## 五、数组

数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。

数组**下标从 `0` 开始**。

### 5.1 定义

数组用小括号表示，元素之间用空格隔开。例如：
```bash
array=(1 abc "def" yxc)
```

也可以直接定义数组中某个元素的值：
```bash
array[0]=1
array[1]=abc
array[2]="def"
array[3]=yxc
```

### 5.2 读取数组中某个元素的值

格式：
```bash
${array[index]}
```

例如：
```bash
array=(1 abc "def" yxc)
echo ${array[0]}
echo ${array[1]}
echo ${array[2]}
echo ${array[3]}
```

### 5.3 读取整个数组

格式：
```bash
${array[@]} # 第一种写法
${array[*]} # 第二种写法
```

例如：
```bash
array=(1 abc "def" yxc)

echo ${array[@]}    # 第一种写法
echo ${array[*]}    # 第二种写法
```

### 5.4 数组长度

类似于字符串：
```bash
${#array[@]}    # 第一种写法
${#array[*]}    # 第二种写法
```

例如：
```bash
array=(1 abc "def" yxc)

echo ${#array[@]}   # 第一种写法
echo ${#array[*]}   # 第二种写法
```

> 注意：在计算数组长度时，未定义的部分就不会被计算在内。
>
> 例如：
> ```shell
> array[0]=0
> array[1]=1
> array[2]=2
> array[1000]=1000
> 
> echo ${array[@]}
> echo ${#array[@]}
> ```
> 输出结果：
> ```bash
> 0 1 2 1000
> 4
> ```
>
> 由上述示例可见，在读取整个数组时，未定义的部分就不会显示，且数组长度也不会将未定义的部分计算在内；即只会显示定义的数组的元素，且只会计算定义的数组的元素的长度。

## 六、`expr` 命令

`expr` 命令用于求表达式的值，格式为：
```shell
expr 表达式
```

表达式说明：
* 用空格隔开每一项。
* 用反斜杠放在 shell 特定的字符前面（发现表达式运行错误时，可以试试转义）。
* 对包含空格和其他特殊字符的字符串要用引号括起来。
* `expr` 会在 `stdout` 中输出结果；如果为逻辑关系表达式，则结果为真时，`stdout` 输出为 `1`，否则输出 `0`。
* `expr` 的 `exit code`：如果为逻辑关系表达式，则结果为真时，`exit code` 为 `0`，否则为 `1`。

### 6.1 字符串表达式

`length STRING`：返回 `STRING` 的长度。

`index STRING CHARSET`：`CHARSET` 中任意单个字符在 `STRING` 中最前面的字符位置，下标从 1 开始；如果在 `STRING` 中完全不存在 `CHARSET` 中的字符，则返回 0。

`substr STRING POSITION LENGTH`：返回 `STRING` 字符串中从 `POSITION` 开始，长度最大为 `LENGTH` 的子串；如果 `POSITION` 或 `LENGTH` 为负数、0 或非数值，则返回空字符串。

示例：
```shell
str="Hello World!"

echo `expr length "$str"`   # `` 不是单引号，表示执行该命令，输出 12
echo `expr index "$str" aWd`    # 输出 7，下标从 1 开始
echo `expr substr "$str" 2 3`   # 输出 ell
```

> 注意：上述示例中 “\` ... \`” 可以替换为 “$( ... )”。

### 6.2 整数表达式

`expr` 支持普通的算术操作，算术表达式优先级低于字符串表达式、高于逻辑关系表达式。
* `+`、`-`：加减运算。两端参数会转换为整数，如果转换失败则报错。
* `*`、`/`、`%`：乘、除、取模运算。两端参数会转换为整数，如果转换失败则报错。
* `()` 可以改变优先级，但需要用反斜杠转义。

示例：
```bash
a=3
b=4

echo `expr $a + $b` # 输出 7
echo `expr $a - $b` # 输出 -1
echo `expr $a \* $b`    # 输出 12，* 需要转义
echo `expr $a / $b` # 输出 0，整除
echo `expr $a % $b` # 输出 3
echo `expr \( $a + 1 \) \* \( $b + 1 \)`    # 输出 20，值为 (a + 1) * (b + 1)
```

> 注意：
>
> 乘法运算的 `*` 的使用除转义外，还有直接加单引号这种方式也可以。如：
> ```shell
> echo `expr $a '*' $b`
> ```
>
> 以上运算之间不管需不需要转义都可以直接加上 `''`，其作用可以理解为告知解释器“我和你们之前定义的不一样”，原来是什么意思就按什么意思来。那些需要转义的可以理解为解释器赋予了它们新的功能，一旦加上 `""` 就意味着不是按解释器赋予的新的意思来执行，而是回归到最原始的意义。

### 6.3 逻辑关系表达式

`|`：如果第一个参数非空且非 0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非 0，否则返回 0；如果第一个参数是非空或非 0 时，不会计算第二个参数。

`&`：如果两个参数都非空且非 0，则返回第一个参数，否则返回 0；如果第一个参数为 0 或为空，则不会计算第二个参数。

`<`、`<=`、`=`、`==`、`!=`、`>=`、`>`：比较两端的参数，如果为 true，则返回 1，否则返回 0；`==` 是 `=` 的同义词。`expr` 首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。

`()` 可以改变优先级，但需要用反斜杠转义。

示例：
```bash
a=3
b=4

echo `expr $a \> $b`    # 输出 0，> 需要转义
echo `expr $a `<` $b`   # 输出 1，也可以将特殊字符用引号引起来
echo `expr $a '>=' $b`  # 输出 0
echo `expr $a \<\= $b`  # 输出 1

c=0
d=5

echo `expr $c \& $d`    # 输出 0
echo `expr $a \& $b`    # 输出 3
echo `expr $c \| $d`    # 输出 5
echo `expr $a \| $b`    # 输出 3
```

## 七、`read` 命令

`read` 命令用于从标准输入中读取单行数据。当读到文件结束符时，`exit code` 为 `1`，否则为 `0`。

参数说明：
* `-p`：后面可以接提示信息。
* `-t`：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令，且后面的命令将会继续执行。

示例代码：
```bash
acs@9e0ebfcd82d7:~$ read name   # 读入 name 的值
acwing yxc  # 标准输入
acs@9e0ebfcd82d7:~$ echo $name  # 输出 name 的值
acwing yxc  # 标准输出
acs@9e0ebfcd82d7:~$ read -p "Please input your name: " -t 30 name   # 读入 name 的值，等待时间 30 秒
Please input your name: acwing yxc  # 标准输入
acs@9e0ebfcd82d7:~$ echo $name  # 输出 name 的值
acwing yxc  # 标准输出
```

## 八、echo 命令

`echo` 用于输出字符串。命令格式：
```bash
echo STRING
```

### 8.1 显示普通字符串

显示普通字符串：
```bash
echo "Hello AC Terminal"
echo Hello AC Terminal  # 引号可以省略
```

### 8.2 显示转义字符

显示转义字符：
```bash
echo "\"Hello AC Terminal\""    # 注意只能使用双引号；如果使用单引号，则不转义
echo \"Hello AC Terminal\"  # 也可以省略双引号
```

### 8.3 显示变量

显示变量：
```bash
name=yxc
echo "My name is $name" # 输出：My name is yxc
```

### 8.4 显示换行

显示换行：
```bash
echo -e "Hi\n"  # -e 开启转义
echo "acwing"
```
输出结果：
```bash
Hi

acwing
```

> 注意：`echo` 默认执行结束后将会换行。

### 8.5 显示不换行

显示不换行：
```bash
echo -e "Hi \c" # -e 开启转义，\c 不换行
echo "acwing"
```
输出结果：
```bash
Hi acwing
```

### 8.6 显示结果定向至文件

显示结果定向至文件：
```bash
echo "Hello World" > output.txt # 将内容以覆盖的方式输出到 output.txt 中
```

### 8.7 原样输出字符串，不进行转义或取变量（用单引号）

原样输出字符串，不进行转义或取变量（用单引号）：
```bash
name=acwing
echo '$name\"'
```
输出结果：
```bash
$name\"
```

### 8.8 显示命令的执行结果

显示命令的执行结果：
```bash
echo `date`
```
输出结果：
```bash
Wed Sep 1 11:45:33 CST 2021
```

## 九、`printf` 命令

printf 命令用于格式化输出，类似于 C / C++ 中的 `printf` 函数。

默认**不会在字符串末尾添加换行符**。

命令格式：
```shell
printf format-string [arguments...]
```

**用法示例：**

脚本内容：
```shell
printf "%10d.\n" 123    # 占 10 位，右对齐
printf "%-10.2f.\n" 123.123321  # 占 10 位，保留 2 位小数（四舍五入），左对齐
printf "My name is %s\n" "yxc"  # 格式化输出字符串
printf "%d * %d = %d\n" 2 3 `expr 2 \* 3`   # 表达式的值作为参数
```

输出结果：
```bash
       123.
123.12    .
My name is yxc
2 * 3 = 6
```

## 十、`test` 命令与判断符号 `[]`

### 10.1 逻辑运算符 && 和 ||

`&&` 表示 与，`||` 表示 或。

二者具有短路原则：
* `expr1 && expr2`：当 `expr1` 为假时，直接忽略 `expr2`。
* `expr1 || expr2`：当 `expr1` 为真时，直接忽略 `expr2`。

> 注意：我们经常会利用 `&&` 和 `||` 的短路原则实现 `if` 判断。

表达式的 `exit code` 为 `0`，表示 真；为 `非零`，表示 假。（**与 C / C++ 中的定义相反。**）

### 10.2 `test` 命令

在命令行中输入 `man test`，可以查看 `test` 命令的用法。

`test` 命令用于判断文件类型，以及对变量做比较。

`test` 命令用 `exit code` 返回结果，而不是使用 `stdout`。返回结果中 `0` 表示 真，`非 0` 表示 假。

示例代码：
```shell
test 2 -lt 3    # 为真，返回值为 0
echo $? # 输出上个命令的返回值，输出 0
```

例如：
```bash
acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件
homework  output.txt  test.sh  tmp
acs@9e0ebfcd82d7:~$ test -e test.sh && echo "exist" || echo "Not exist"
exist   # test.sh 文件存在
acs@9e0ebfcd82d7:~$ test -e test2.sh && echo "exist" || echo "Not exist"
Not exist   # test2.sh 文件不存在
```

### 10.3 文件类型判断

命令格式：
```shell
test -e filename    # 判断文件是否存在
```

| 测试参数 | 代表意义 |
| :--: | :--: |
| `-e` | 文件是否存在 |
| `-f` | 是否为文件 |
| `-d` | 是否为目录 |

> 注意：
> 
> 为了更规范、避免出现极端情况（**例如文件名含空格**），建议给 filename 加双引号 `""`：
> ```shell
> test -e "filename"
> ```
>
> 以避免带空格文件名造成错误。

### 10.4 文件权限判断

命令格式：
```shell
test -r filename    # 判断文件是否可读
```

| 测试参数 | 代表意义 |
| :--: | :--: |
| `-r` | 文件是否可读 |
| `-w` | 文件是否可写 |
| `-x` | 文件是否可执行 |
| `-s` | 是否为非空文件 |

> 注意：
>
> 为了更规范、避免出现极端情况（例如文件名含空格），建议给 `filename` 加双引号 `""`：
> ```shell
> test -r "filename"
> ```
>
> 以避免带空格文件名造成错误。

### 10.5 整数间的比较

命令格式：
```shell
test $a -eq $b  # a 是否等于 b
```

| 测试参数 | 代表意义 |
| :--: | :--: |
| `-eq` | `a` 是否等于 `b` |
| `-ne` | `a` 是否不等于 `b` |
| `-gt` | `a` 是否大于 `b` |
| `-lt` | `a` 是否小于 `b` |
| `-ge` | `a` 是否大于等于 `b` |
| `-le` | `a` 是否小于等于 `b` |

### 10.6 字符串比较

| 测试参数 | 代表意义 |
| :--: | :--: |
| `test -z STRING` | 判断 `STRING` 是否为空；如果为空，则返回 `true` |
| `test -n STRING` | 判断 `STRING` 是否非空；如果非空，则返回 `true`（`-n` 可以省略） |
| `test str1 == str2` | 判断 `str1` 是否等于 `str2` |
| `test str1 != str2` | 判断 `str1` 是否不等于 `str2` |

### 10.7 多重条件判定

命令格式：
```shell
test -r filename -a -x filename
```

| 测试参数 | 代表意义 |
| :--: | :--: |
| `-a` | 两条件是否同时成立 |
| `-o` | 两条件是否至少一个成立 |
| `!` | 取反。如 `test ! -x file`，当 `file` 不可执行时，返回 `true` |

### 10.8 判断符号 `[]`

`[]` 与 `test` 用法几乎一模一样，更常用于 `if` 语句中。另外 `[[]]` 是 `[]` 的加强版，支持的特性更多。

示例代码：
```shell
[ 2 -lt 3]  # 为真，返回值为 0
echo $? # 输出上个命令的返回值，输出 0
```

例如：
```bash
acs@9e0ebfcd82d7:~ ls   # 列出当前目录下的所有文件
homework  output.txt  test.sh  tmp
acs@9e0ebfcd82d7:~ [ -e test.sh ] && echo "exist" || echo "Not exist"
exist   # test.sh 文件存在
acs@9e0ebfcd82d7:~ [ -e test2.sh ] && echo "exist" || echo "Not exist"
Not exist   # test2.sh 文件不存在
```

注意：
* `[]` 内的每一项都要用空格隔开；
* 中括号内的变量，最好用双引号括起来；
* 中括号内的常数，最好用单或双引号括起来。

例如：
```shell
name="acwing yxc"
[ $name == "acwing yxc" ]   # 错误，等价于 [ acwing yxc == "acwing yxc" ]，参数太多
[ "$name" == "acwing yxc" ] # 正确
```

## 十一、判断语句

shell 中的判断语句采用 `if ... then` 形式，类似于 C / C++ 中的 `if - else` 语句。

### 11.1 单层 `if`

命令格式：
```shell
if condition
then
    语句 1
    语句 2
    ...
fi
```

示例代码：
```shell
a=3
b=4

if [ "$a" -lt "$b" ] && [ "$a" -gt 2 ]
then
    echo ${a}在范围内
fi
```
输出结果：
```bash
3在范围内
```

### 11.2 单层 `if - else`

命令格式：
```shell
if condition
then
    语句 1
    语句 2
    ...
else
    语句 1
    语句 2
    ...
fi
```

示例代码：
```shell
a=3
b=4

if ! [ "$a" -lt "$b" ]
then
    echo ${a}不小于${b}
else
    echo ${a}小于${b}
fi
```
输出结果：
```bash
3小于4
```

### 11.3 多层 `if - elif - elif - else`

命令格式：
```shell
if condition
then
    语句 1
    语句 2
    ...
elif condition
then
    语句 1
    语句 2
    ...
elif condition
then
    语句 1
    语句 2
    ...
else
    语句 1
    语句 2
    ...
fi
```

示例代码：
```shell
a=4

if [ $a -eq 1 ]
then
    echo ${a}等于1
elif [ $a -eq 2 ]
then
    echo ${a}等于2
elif [ $a -eq 3 ]
then
    echo ${a}等于3
else
    echo 其他
fi
```
输出结果：
```bash
其他
```

### 11.4 `case ... esac` 形式

类似于 C / C++ 中的 `switch` 语句。

命令格式：
```shell
case $变量名称 in
    值1)
        语句 1
        语句 2
        ...
        ;;  # 类似于 C / C++ 中的 break
    值2)
        语句 1
        语句 2
        ...
        ;;
    *)  # 类似于 C / C++ 中的 default
        语句 1
        语句 2
        ...
        ;;  # 可以删除，但是不推荐删除
esac
```

示例代码：
```shell
a=4

case $a in
    1)
        echo ${a}等于1
        ;;
    2)
        echo ${a}等于2
        ;;
    3)
        echo ${a}等于3
        ;;
    *)
        echo 其他
        ;;
esac
```
输出结果：
```bash
其他
```

## 十二、循环语句

### 12.1 `for ... in ... do ... done`

命令格式：
```shell
for var in var1 var2 var3   # var 枚举 var1、var2、var3
do
    语句 1
    语句 2
    ...
done
```

示例代码 1 - 输出 `a`、`2`、`cc` 且每个元素一行：
```shell
for i in a 2 cc
do
    echo $i
done
```

示例代码 2 - 输出当前路径下的所有文件名且每个文件名一行：
```shell
for file in `ls`
do
    echo $file
done
```

示例代码 3 - 输出 1 - 10：
```shell
for i in $(seq 1 10)
do
    echo $i
done
```

> 注意：`seq` 命令将返回一个每一项都带有回车符的序列。

示例代码 4 - 使用 `{1..10}` 或者 `{a..z}`：
```shell
for i in {a..z}
do
    echo $i
done
```

> 注意：`{10..1}` 和 `{z..a}` 的写法也可以。

### 12.2 for ((...;...;...)) do...done

命令格式：
```shell
for ((expression; condition; expression))
do
    语句 1
    语句 2
done
```

示例代码 - 输出 `1 - 10` 且每个数占一行：
```shell
for ((i=1; i<=10; i++))
do
    echo $i
done
```

### 12.3 `while ... do ... done` 循环

命令格式：
```shell
while condition
do
    语句 1
    语句 2
    ...
done
```

示例代码：
```shell
while read name
do
    echo $name
done
```

上述程序在运行过程中，当执行 `Ctrl + d` 时该程序将会读入文件结束符，此时程序结束。

> 注意：`Ctrl + d` 将会返回文件结束符来结束该进程，而 `Ctrl + c` 将会杀死该进程。

### 12.4 `until ... do ... done` 循环

当条件为真时结束。

命令格式：
```shell
until condition
do
    语句 1
    语句 2
    ...
done
```

示例代码：
> 当用户输入 `yes` 或者 `YES` 时结束，否则一直等待读入。

```shell
until [ "${word}" == "yes" ] || [ "${word}" == "YES" ]
do
    read -p "Please input yes/YES to stop this program: " word
done
```

### 12.5 `break` 命令

跳出当前一层循环。注意与 C / C++ 不同的是：`break` 不能跳出 `case` 语句。

示例代码：
```shell
while read name
do
    for ((i=1;i<=10;i++))
    do
        case $i in
            8)
                break
                ;;
            *)
                echo $i
                ;;
        esac
    done
done
```
上述示例代码每读入非 EOF 的字符串，会输出一遍 `1 - 7`。
该程序可以输入 `Ctrl + d` 文件结束符来结束，也可以直接用 `Ctrl + c` 杀掉该进程。

### 12.6 `continue` 命令

跳出当前循环。

示例代码：
```shell
for ((i=1;i<=10;i++))
do
    if [ `expr $i % 2` -eq 0 ]
    then
        continue
    fi
    echo $i
done
```
上述程序输出 `1 - 10` 中的所有奇数。

### 12.7 死循环的处理方式

如果 AC Terminal 可以打开该程序，则输入 `Ctrl + c` 即可；否则可以直接关闭进程：
1. 使用 `top` 命令找到进程的 PID；
2. 输入 `kill -9 PID` 即可关掉此进程。

> 注意：在 `top` 中执行 `Shift + N` 将会以 PID 排序显示。

## 十三、函数

`bash` 中的函数类似于 C / C++ 中的函数，但 `return` 的返回值与 C / C++ 不同，返回的是 `exit code`，取值为 `0 - 255`，`0` 表示正常结束，且默认返回 `0`。

如果想获取函数的输出结果，可以通过 `echo` 输出到 `stdout` 中，然后通过 `$(function_name)` 来获取 `stdout` 中的结果。

函数的 `return` 值可以通过 `$?` 来获取。

命令格式：
```shell
[function] func_name() {    # function 关键字可以省略
    语句 1
    语句 2
    ...
}

func_name   # 调用函数，不需要在 func_name 后加 ()
```

> 注意：
> 
> 即使存在输入参数，在调用函数时也不需要在 `func_name` 后加 `()`，例如：
> ```shell
> func() {
>     # ...
> }
> 
> echo $(func 10)
> ```
>
> 上述代码中，向函数 `func` 传入输入参数 `10` 时直接写为 `func 10`，而不可写为 `func(10)`。

### 13.1 不获取 `return` 值和 `stdout` 值

示例代码：
```shell
func() {
    name=yxc
    echo "Hello $name"
}

func
```
输出结果：
```bash
Hello yxc
```

### 13.2 获取 `return` 值和 `stdout` 值

不写 `return` 时，默认 `return 0`。

示例代码：
```shell
func() {
    name=yxc
    echo "Hello $name"

    return 123
}

output=$(func)  # 或：output=`func`
ret=$?

echo "output = $output"
echo "return = $ret"
```
输出结果：
```bash
output = Hello yxc
return = 123
```

### 13.3 函数的输入参数

在函数内，`$1` 表示第一个输入参数，`$2` 表示第二个输入参数，依此类推。

> 注意：函数内的 `$0` 仍然是文件名，而不是函数名。

示例代码：
```shell
func() {    # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0
    word=""
    while [ "${word}" != 'y' ] && [ "${word}" != 'n' ]
    do
        read -p "要进入func($1)函数吗？请输入y/n：" word
    done

    if [ "$word" == 'n' ]
    then
        echo 0
        return 0
    fi

    if [ $1 -le 0 ]
    then
        echo 0
        return 0
    fi

    sum=$(func $(expr $1 - 1))
    echo $(expr $sum + $1)
}

echo $(func 10)
```
输出结果：
```bash
55
```

### 13.4 函数内的局部变量

可以在函数内定义局部变量，作用范围仅在当前函数内。

可以在递归函数中定义局部变量。

命令格式：
```shell
local 变量名=变量值
```

示例代码：
```shell
#! /bin/bash

func() {
    local name=yxc
    echo $name
}

echo $name
```
输出结果：
```bash
yxc

```
上述代码中，第一行为函数内的 `name` 变量，第二行为函数外调用 `name` 变量，会发现此时该变量不存在。

## 十四、`exit` 命令

`exit` 命令用来退出当前 shell 进程，并返回一个退出状态；使用 `$?` 可以接收这个退出状态。

`exit` 命令可以接受一个整数值作为参数，代表退出状态；如果不指定，默认状态值是 `0`。

`exit` 退出状态只能是一个介于 `0 ~ 255` 之间的整数，其中只有 `0` 表示成功，其它值都表示失败。

示例代码：
> 创建脚本 `test.sh`，内容如下。

```shell
#! /bin/bash

if [ $# -ne 1 ] # 如果传入参数个数等于 1，则正常退出；否则非正常退出。
then
    echo "arguments not valid"
    exit 1
else
    echo "arguments valid"
    exit 0
fi
```
执行上述脚本：
```bash
acs@9e0ebfcd82d7:~$ chmod +x test.sh
acs@9e0ebfcd82d7:~$ ./test.sh acwing
arguments valid
acs@9e0ebfcd82d7:~$ echo $? # 传入一个参数，则正常退出，exit code 为 0
0
acs@9e0ebfcd82d7:~$ ./test.sh
arguments not valid
acs@9e0ebfcd82d7:~$ echo $? # 传入参数个数不是 1，则非正常退出，exit code 为 1
1
```

## 十五、文件重定向

每个进程默认打开 3 个文件描述符：
* `stdin`：标准输入，从命令行读取数据，文件描述符为 0。
* `stdout`：标准输出，向命令行输出数据，文件描述符为 1。
* `stderr`：标准错误输出，向命令行输出数据，文件描述符为 2。

可以用文件重定向将这三个文件重定向到其他文件中。

### 15.1 重定向命令列表

| 命令 | 说明 |
| :--: | :--: |
| `command > file` | 将 `stdout` 重定向到 `file` 中 |
| `command < file` | 将 `stdin` 重定向到 `file` 中 |
| `command >> file` | 将 `stdout` 以追加方式重定向到 `file` 中 |
| `command n> file` | 将文件描述符 `n` 重定向到 `file` 中 |
| `command n>> file` | 将文件描述符 `n` 以追加方式重定向到 `file` 中 |

### 15.2 输入和输出重定向

示例代码：
```shell
echo -e "Hello \c" > output.txt # 将 stdout 重定向到 output.txt 中
echo "World" >> output.txt  # 将字符串追加到 output.txt 中

read str < output.txt   # 从 output.txt 中读取字符串

echo $str   # 输出结果：Hello World
```

### 15.3 同时重定向 `stdin` 和 `stdout`

创建 `bash` 脚本：
```shell
#! /bin/bash

read a
read b

echo $(expr "$a" + "$b")
```

创建 `input.txt`，里面的内容为：
```txt
3
4
```

执行命令：
```bash
acs@9e0ebfcd82d7:~$ chmod +x test.sh    # 添加可执行权限
acs@9e0ebfcd82d7:~$ ./test.sh < input.txt > output.txt  # 从 input.txt 中读取内容，将输入写入 output.txt 中
acs@9e0ebfcd82d7:~$ cat output.txt  # 查看 output.txt 中的内容
7
```

> 注意：`./test.sh < input.txt > output.txt` 也可以改变顺序写为 `./test.sh > output.txt < input.txt`。

## 十六、引入外部脚本

类似于 C / C++ 中的 `include` 操作，`bash` 也可以引入其他文件中的代码。

语法格式：
```shell
. filename  # 注意 . 和 文件名 之间有一个空格

或

source filename # 将 filename 的内容全部复制到这里
```

> 注意：`filename` 可以添加绝对路径。

关于 `source` 命令：一般情况下，我们在更新完 `.bashrc` 配置文件之后，需要使用 `source .bashrc` 命令告知 bash 执行 `.bashrc` 文件；但 `source` 命令不可用于 `.vimrc` 配置文件，即不可写为 `source .vimrc`，因为 `.vimrc` 不是使用 shell 语法编写的，无法使用 `source` 命令来运行。

> 注意：Linux 下启动 bash 时将会执行 `.bashrc` 文件初始化 bash 配置（如配置环境变量等参数）。

**示例：**

创建 `test1.sh`，内容为：
```shell
#! /bin/bash

name=yxc    # 定义变量 name
```

> 注意：`test1.sh` 文件仅需要可读权限即可。

然后创建 `test2.sh`，内容为：
```shell
#! /bin/bash

source test1.sh # 或 . test1.sh

echo My name is: $name  # 可以使用 test1.sh 中的变量
```

执行命令：
```bash
acs@9e0ebfcd82d7:~$ chmod +x test2.sh
acs@9e0ebfcd82d7:~$ ./test2.sh
My name is: yxc
```